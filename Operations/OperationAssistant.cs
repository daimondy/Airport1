using Airport.Planes;
using Airport.AirportManagement;

namespace Airport.Operations
{
    /*
        Выполняет свои задачи каждый заданный тактовый интервал
        Работает так:
            если самолеты в воздушном пространстве:
                - отправляет обратно, если они разгружены
                - попытается приземлиться, если не разгружен
            если самолеты на взлетно-посадочной полосе:
                - стартует, если они перед взлетом и не загружены
                - сбрасывает ресурсы, если они после приземления не были сброшены
                - оставляет самолеты в ангаре, если они разгружены
            если самолеты в ангаре:
                - начинает заправку -> техосмт -> уходит        
    */
    class OperationAssistant : IOperation
    {
        private int intervalTimer;

        public OperationAssistant()
        { }

        public override bool execute()
        {
            if (++intervalTimer < Constants.intervalAssistant) return true;
            intervalTimer = 0;
            
            foreach(Plane plane in AirportManager.getInstance().getHangar().getList())
            {
                if (!plane.isAutoGenerated()) continue;
                if(plane == AirportManager.getInstance().getSelectedPlane()) continue;

                if (plane.getCurrentState() != State.Hangar) continue;

                if (!plane.isEmpty())
                {
                    if (plane is PassengerPlane)
                        AirportManager.getInstance().unloadPeopleOperation(plane);
                    else if (plane is TransportPlane)
                        AirportManager.getInstance().unloadCargoOperation(plane);
                    else
                        AirportManager.getInstance().unloadAmmoOperation(plane);

                }
                else if (!plane.isTanked()) AirportManager.getInstance().fuel(plane);
                else if (!plane.isAfterTechnicalInspection()) AirportManager.getInstance().inspectTechnically(plane);
                else
                {
                    AirportManager.getInstance().placeOnRunway(plane);
                    break;
                }

            }

            foreach(Runway runway in AirportManager.getInstance().getRunwayList())
            {
                if (runway.getPlane() == null) continue;
                Plane plane = runway.getPlane();

                if (!plane.isAutoGenerated()) continue;
                if (plane == AirportManager.getInstance().getSelectedPlane()) continue; 

                if (plane.getCurrentState() == State.OnRunwayAftLanding)
                {
                    if (!plane.isEmpty() && plane is PassengerPlane)
                    {
                        AirportManager.getInstance().unloadPeopleOperation(plane);
                    }
                    else
                    {
                        AirportManager.getInstance().placeInHangar(plane);
                    }
                }
                else if(plane.getCurrentState() == State.OnRunwayBefTakeoff)
                {
                    AirportManager.getInstance().takeOff(plane);
                }
            }

            foreach(Plane plane in AirportManager.getInstance().getAirspace().getList())
            {
                if (!plane.isAutoGenerated()) continue;
                if (plane == AirportManager.getInstance().getSelectedPlane()) continue;

                if (plane.isEmpty())
                {
                    AirportManager.getInstance().sendAway(plane);
                    break;
                }
                else
                {
                    AirportManager.getInstance().land(plane);
                    break;
                }
            }
            

            return true;
        }

        public override Plane getPlane()
        {
            return null;
        }

        public override void stop()
        {

        }
    }
}
